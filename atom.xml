<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>dpatrickx&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.dpatrickx.com/"/>
  <updated>2017-12-28T07:45:54.957Z</updated>
  <id>http://blog.dpatrickx.com/</id>
  
  <author>
    <name>dpatrickx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo博客搭建</title>
    <link href="http://blog.dpatrickx.com/2017/12/24/blog/"/>
    <id>http://blog.dpatrickx.com/2017/12/24/blog/</id>
    <published>2017-12-24T03:15:00.000Z</published>
    <updated>2017-12-28T07:45:54.957Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Install-hexo-on-Mac"><a href="#Install-hexo-on-Mac" class="headerlink" title="Install hexo on Mac"></a>Install hexo on Mac</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="Change-theme-into-maupassant-refe"><a href="#Change-theme-into-maupassant-refe" class="headerlink" title="Change theme into maupassant refe"></a>Change theme into maupassant <a href="https://github.com/tufu9441/maupassant-hexo" target="_blank" rel="noopener">refe</a></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-pug --save</span><br><span class="line">npm install hexo-renderer-sass --save</span><br><span class="line">change theme to maupassant <span class="keyword">in</span> _config.yml</span><br></pre></td></tr></table></figure><h3 id="Deploy"><a href="#Deploy" class="headerlink" title="Deploy"></a>Deploy</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add follows in _config.yml</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/dpatrickx/dpatrickx.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  message: blog update</span><br><span class="line"></span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><h3 id="Add-Mathjax"><a href="#Add-Mathjax" class="headerlink" title="Add Mathjax"></a>Add Mathjax</h3><p>Add Mathjax Support like $a_b$</p>]]></content>
    
    <summary type="html">
    
      Build hexo blog on Github pages
    
    </summary>
    
      <category term="blog" scheme="http://blog.dpatrickx.com/categories/blog/"/>
    
    
      <category term="blog" scheme="http://blog.dpatrickx.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>足球机器人 - 球场检测</title>
    <link href="http://blog.dpatrickx.com/2016/07/31/soccerRobot/"/>
    <id>http://blog.dpatrickx.com/2016/07/31/soccerRobot/</id>
    <published>2016-07-31T15:00:00.000Z</published>
    <updated>2017-12-28T07:27:00.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-概况"><a href="#1-概况" class="headerlink" title="1. 概况"></a>1. 概况</h3><p>在本部分我主要负责检测球场和确定机器人位置的工作.<br>具体可以分为:</p><ol><li>根据标注出白线的kinect视角图(424*512)，进行坐标映射、直线拟合来确定视野中属于的各条线;</li><li>在1的基础上确定机器人的坐标及朝向.</li></ol><h3 id="2-坐标系说明"><a href="#2-坐标系说明" class="headerlink" title="2. 坐标系说明"></a>2. 坐标系说明</h3><ul><li>图片坐标系(rc): 左上角为(0, 0), r轴向右, c轴向下;</li><li>kinect坐标系(xyz): 即kinect坐标系, 以kinect镜头为原点, x轴向左, z轴为镜头法线方向, y轴与z轴垂直, 指向上;pict 1</li></ul><p><img src="http://i.imgur.com/mkdYPfM.png" alt=""></p><ul><li>机器人坐标系(uv): 以左上角为原点, u轴向右, v轴向下的机器人视角平面图. 机器人为(423, 255)点;</li><li>世界坐标系(XY): 在球场中的坐标系, 面向对方半场, 以左上角为原点, u轴沿底线向右, v轴沿边线向后.</li></ul><h3 id="3-坐标变换方法"><a href="#3-坐标变换方法" class="headerlink" title="3. 坐标变换方法"></a>3. 坐标变换方法</h3><p>通过之前同学的视觉识别工作, 已经可以标记出kinect深度图中属于白线的部分, 即知道白线的图片坐标.</p><p>在此基础上调用libfreenect2中getPointXYZ()函数, 可以获知kinect深度图视野中任一点在kinect坐标系下的坐标, 即知道图片的kinect坐标.</p><p>接下来要做的工作就是将kinect坐标转换为机器人坐标, 在实验中我们是将kinect固定在机器人最上方, 用俯瞰的方式来观察球场, 因此kinect和水平面之间有一个固定夹角. 如下图:</p><p><img src="http://i.imgur.com/qfwokQG.png" alt=""></p><p>通过图中所示, 可知, kinect坐标系下(x, y, z)映射到机器人坐标(u, v)的映射关系为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u = 256 +　x</span><br><span class="line">v = 424 - (z*cos(theta) + ｄ)</span><br></pre></td></tr></table></figure></p><p>其中ｄ是为了将坐标修正到机器人中心所加常数, theta是kinect与水平面所成夹角, 该余弦值可以经过预先测定获取．</p><p>因为kinect所得视野左右颠倒, 因此在这里对u坐标取反.</p><p><img src="http://i.imgur.com/mpvEm3Y.png" alt=""></p><p>不难发现, 该映射对球场完全成立的前提是球场各点高度相等, 因此当球场上存在褶皱时, 该映射对褶皱部分所得的v值会偏小, 因此褶皱部分在所得平面图中影响会被放大, 如下图, 底线上的褶皱导致所得平面图很不规整.</p><p><img src="http://i.imgur.com/pafT2ro.png" alt=""></p><h3 id="4-球场检测"><a href="#4-球场检测" class="headerlink" title="4. 球场检测"></a>4. 球场检测</h3><p>接下来所要做的工作就是用直线来拟合球场的边线\禁区线, 这部分也是整个部分耗时最多, 代码量最多的部分. 究其原因就是3中所得平面图中各条边线并不规整. 因此用了很多 取平均/求拟合 的方法来尝试得到较好的匹配结果.</p><h4 id="4-1-直线拟合"><a href="#4-1-直线拟合" class="headerlink" title="4.1 直线拟合"></a>4.1 直线拟合</h4><p>往届中有使用直线拟合来完成本工作的例子, 因此最开始选取此方法来对球场进行拟合, 尝试用拟合+筛选的结果来作为球场匹配结果, 具体思路如下:</p><ol><li>使用Canny算子完成边检测, 即理想情况下只保留各条白线的边框, 实际操作中可以在本步之前加一些模糊操作;</li></ol><p><img src="http://i.imgur.com/xckYzCF.png" alt=""></p><ol><li>使用霍夫变换来检测直线, 因为1中只保留了白线边框, 因此这里可以对拟合结果进行一定的平移, 以达到拟合白线中心的目的;</li><li>对所得直线进行筛选, 可以采用判断 经过白点总数/连续经过白点数目的方式;</li><li>如果两条直线距离在一定范围内, 进行合并, 保留经过白点数量多的直线, 反复执行直到没有可以合并的直线为止;</li><li>所得即为最终拟合结果.</li></ol><p>因为存在之前所提的边线不规整的原因, 所以本步得到的结果很糟糕, 几乎不能用来进行匹配和定位, 如下图:</p><p><img src="http://i.imgur.com/897UO9G.png" alt=""></p><h4 id="4-2-固定模式匹配"><a href="#4-2-固定模式匹配" class="headerlink" title="4.2 固定模式匹配"></a>4.2 固定模式匹配</h4><p>在4.1基础上, 最后采用了 “先确定球场大致位置, 再用规整的球场来拟合角度” 的思路.</p><h5 id="4-2-1-确定角球点"><a href="#4-2-1-确定角球点" class="headerlink" title="4.2.1 确定角球点"></a>4.2.1 确定角球点</h5><p>因为角球区特征最为明显, 而且容易确定原点位置, 因此我们尝试先利用4.1中的算法大致确定球场是否是角球区, 如果是的话, 再找到角球点位置, 再在角球点周围, 用标准的球场线来”拟合”白点, 拟合白点最多的角度就是配准后的结果.</p><p>按这个思路, 接下来的重点就是如何判断角球区以及如何准确地找到角球点位置.</p><p>首先为了排除干扰, 先反复使用erode和dialite函数来获取白线的skeleton, 再去除图中的孤立点, 结果如下图:</p><p><img src="http://i.imgur.com/2aQrrYj.png" alt=""></p><ul><li><p>判断角球区:</p><ol><li>角球区一般拟合结果会有4条距离较近的直线, 因此可以用直线距离作为判断准则;</li><li>角球区另一个特点就是有两条边线, 边线的确定可以遍历所有白点, 如果大多数白点都在直线的某一侧, 就可以将该条直线看做边线.</li></ol></li><li><p>获取角球点:</p><ol><li>之前判断出的两条变线的交点就是角球点的大致方位;</li><li>在该交点旁边寻找最近的白点来当做角球点即可, 经过检验准确度基本可以得到保证.</li></ol></li></ul><p>实际算法中, 在上述判断标准的基础上都进行了一些 遍历相邻节点/取最优 操作, 以对结果做一定修正.</p><h5 id="4-2-2-匹配整体球场"><a href="#4-2-2-匹配整体球场" class="headerlink" title="4.2.2 匹配整体球场"></a>4.2.2 匹配整体球场</h5><p>在完成4.2.1操作后, 如果机器人视野中包括角球区, 那么已经可以确定角球点的位置, 接下来需要用已知标准的球场来拟合即可, 思路如下:</p><ol><li>用一根直线绕角球点旋转, 取经过白点最多角度, 如果经过的白点数量大于某一阙值, 进行2;</li><li>在1基础上, 用垂直于该边线的另一条直线来拟合白点, 如果经过白点数量大于一个阙值, 进行3;</li><li>在2基础上, 用经过白点数量来确定大禁区线位置, 同时也确定了1和2中确定直线哪条是底线, 哪条是边线.</li></ol><p>为了防止角球点位置不对导致错误匹配结果, 选取4.2.1中所得角球点周围若干点(实验中选16个)同时进行上述1/2操作, 如果1和2都成立, 则记录该角度, 到最后取平均角度作为最终边线/底线的角度. 通过检验, 可以得到较好效果, 随着机器人行走也可以较为及时地确定当前球场.</p><p><img src="http://i.imgur.com/p468GjV.png" alt=""></p><p>需要注意的是, 在某些特定角度, 和底线平行的大禁区线同样会被认定为底线, 因此4.2.1有可能会返回多个角球点, 这里可以按照角球点的图片坐标来区分, 因为机器人视野下的底线一定比禁区线更远, 因此选取图片坐标系中更靠上方的交点即可.</p><p>实际算法中, 在上述基础上, 加入了一些对特殊情况的判断. 参见代码.</p><h3 id="5-检测机器人坐标及朝向"><a href="#5-检测机器人坐标及朝向" class="headerlink" title="5. 检测机器人坐标及朝向"></a>5. 检测机器人坐标及朝向</h3><p>在完成4操作后, 已经得到了匹配后的球场结果. 接下来就需要根据机器人看到的机器人坐标系比来得到机器人在世界坐标系(XY)下的坐标.</p><p>因为已经确定了球场的两条边线的直线方程, 又已知机器人位于(423, 255)点, 因此只需要判断该角球点是在左还是在右即可, 这里先得到机器人和底线中点所连直线的方程, 再将角球点坐标代入, 判断正负即可知道左右.</p><p>在获知左右后, 即可知道机器人的世界坐标(X, Y), 判断底线和水平线夹角即可知道机器人的朝向.</p><p><img src="http://i.imgur.com/OgWrR4Q.png" alt=""></p><p>具体参见代码相应部分.</p><h3 id="6-检测足球世界坐标"><a href="#6-检测足球世界坐标" class="headerlink" title="6. 检测足球世界坐标"></a>6. 检测足球世界坐标</h3><p>在之前同学的视觉检测部分, 可以获取到球的机器人坐标, 在已知机器人的世界坐标的前提下, 可以求出足球的世界坐标, 需要注意的是在不同朝向范围内计算公式有一定区别, 虽然只是高中数学但还是需要认真推导, 实验中为了这个调了挺长时间Orz</p><p>具体参见代码相应部分.</p><h3 id="7-配置"><a href="#7-配置" class="headerlink" title="7. 配置"></a>7. 配置</h3><p>在qt下导入运行即可.<br>加入配置如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">CONFIG += c++11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">DEFINES += TEST_LIBRARY</span><br><span class="line"></span><br><span class="line">SOURCES += test.cpp \</span><br><span class="line">    matchpos.cpp</span><br><span class="line"></span><br><span class="line">HEADERS += test.h\</span><br><span class="line">        test_global.h \</span><br><span class="line">    matchpos.h</span><br><span class="line"></span><br><span class="line">INCLUDEPATH += /usr/local/include \</span><br><span class="line">                /usr/local/include/opencv \</span><br><span class="line">                /usr/local/include/opencv2</span><br><span class="line"></span><br><span class="line">LIBS += /usr/local/lib/libopencv_highgui.so \</span><br><span class="line">        /usr/local/lib/libopencv_core.so    \</span><br><span class="line">        /usr/local/lib/libopencv_imgproc.so \</span><br><span class="line">        /usr/local/lib/libopencv_photo.so</span><br></pre></td></tr></table></figure></p><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h3><p>本部分实现原理比较简单, 主要工作都在调试改动上, 因为平面图像的误差导致用了很多奇怪的方法来匹配球场, 拟合坐标.</p><p>总结来看, 在刚开始还是对整体识别思路理得不够清楚, 有些地方可以用更好更简洁的方法来处理; 此外在各种角度计算统一上也出了很多bug, 也属于一开始没有统一好的锅..</p><p>最后郑重感谢老师和助教在小学期里的辛勤指导, 在很多地方给予了我们很关键的帮助.</p>]]></content>
    
    <summary type="html">
    
      小学期足球机器人项目, 负责球场检测+坐标计算部分..
    
    </summary>
    
      <category term="course" scheme="http://blog.dpatrickx.com/categories/course/"/>
    
    
      <category term="opencv" scheme="http://blog.dpatrickx.com/tags/opencv/"/>
    
  </entry>
  
  <entry>
    <title>四子棋ai</title>
    <link href="http://blog.dpatrickx.com/2016/02/29/four-chess/"/>
    <id>http://blog.dpatrickx.com/2016/02/29/four-chess/</id>
    <published>2016-02-29T03:15:00.000Z</published>
    <updated>2017-12-28T07:29:51.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验描述"><a href="#实验描述" class="headerlink" title="实验描述"></a>实验描述</h3><p>本实验对要求实现一个变种四子棋的 AI, 实验中对四子棋规则做了一定的扩展, 即随机 确定棋盘大小以及在棋盘上生成不可落子点. 要求在所给的实验框架下完成四子棋游戏的人 工智能决策部分并进行相应封装, 对于每次传 入的棋盘状态后返回一个落子点.</p><h2 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h2><p>在实验中我选择了蒙特卡洛算法, 评测结果较好, 以下简单就本实验算法选 择进行一定分析.  实验指导中推荐使用 alpha-beta 剪枝算法,  但使用 alpha-beta 剪枝算法的 难点是很难设计出较好的估价函数. 由于棋盘大小不定并且有不可落子点, 要找 到能够很合理地反应当前局面的估价函数并不容易, 则算法瓶颈落在了设计部分 上,  体现不出机器的优势,  要实现较好的改进也并不容易.  而蒙特卡洛算法则不存在这样的瓶颈问题,  蒙特卡洛算法的基本思路是对每 个点进行随机模拟落子直至比赛结束,  选胜率最高的点作为最终返回的落子点.  在模拟点数量较多时, 算法会逐渐收敛到当前最优解. 相比 alpha-beta 剪枝算 法, 蒙特卡洛算法可以看作用机器的优势来和人对弈,  在算法设计部分只需要做 到均衡算法过程中的模拟方向, 使每个点都能有一定量的模拟, 从而使结果更可 靠. 从以上分析不难看出,  蒙特卡洛算法成功与否主要取决于能否在给定时间内 进行较多次数的迭代.  在具体实现中,  为了保证迭代的次数和收敛效率, 可以以空间来换时间,  建 立一颗搜索树来记录每一个模拟局面下的胜率等信息,  在 5s 的时间限制内, 可 以生成 200W 个节点,  与 100.dll 对战时, 胜率也可以保持在 60%的水平.  需要指出的是,  蒙特卡洛算法在出解速度上远逊于 alpha-beta 剪枝. 同时, 如 果 alpha-beta 剪枝算法可以设计出一个很好的估价函数, 效果也可以好于蒙特 卡洛算法.</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ol><li><p>初始化棋局,  用 0 作为父节点, 即整棵树的根节点,  代表当前棋局状态;</p></li><li><p>如果满足终止条件(经过时间达到一定时间), 跳至 6;</p></li><li><p>判断父节点是否为叶子节点： 如果父节点为叶子节点,  那么对父节点进行扩展,  对扩展出的每一个 子节点都进行模拟对局,  并向上更新祖先几点的 totRound 和 winRound 信息; 如果父节点不是叶子节点,  不进行操作;</p></li><li><p>在父节点的子节点中选取 UCB 值最大的节点;</p></li><li><p>判断此节点对应的棋局状态是否已分出胜负:</p><ul><li><p>如果已经分出胜负,  再次向上更新 winRound 和 totRound 信息,  将父 节点置为 0, 跳至 2;</p></li><li><p>如果未分出胜负,  将选出的节点作为父节点,  跳至 2;</p></li></ul></li><li><p>从根节点的子节点中选取胜率最大点, 将该点记录坐标作为最终返回点.</p></li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><ol><li><p><strong>MCNode 类：</strong><br>记录每一个节点的信息(即每新走一个棋子对应的一个棋盘状态)<br>x y 为最新加入棋子坐标<br>winRound 和 totRound 记录这个状态下 user 的胜场数和总场数, 需要注意的是父节点<br>和子节点的 user 不一样, 更新胜场数的时候也需要隔层更新</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MCNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="keyword">int</span> lChild,rChild,father;</span><br><span class="line">    <span class="keyword">bool</span> user,isLeaf; <span class="comment">// user: false--&gt;oppoent, true--&gt;me</span></span><br><span class="line">    <span class="keyword">int</span> winRound, totRound;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局变量：</strong><br>为了加快迭代速度,  用全局数组来创建树结构,  并在全局创建 tempTop1/2和tempBoard1/2 来记录临时的棋局状态以方便对树中节点进行扩展和模拟</p> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MCNode nodes[NODENUM];</span><br><span class="line"><span class="keyword">int</span> rank;</span><br><span class="line"><span class="keyword">int</span> sel;</span><br><span class="line"><span class="keyword">int</span> fNode = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* tempTop1;</span><br><span class="line"><span class="keyword">int</span>* tempTop2; <span class="comment">// used for modify function</span></span><br><span class="line"><span class="keyword">int</span>** tempBoard1;</span><br><span class="line"><span class="keyword">int</span>** tempBoard2; <span class="comment">// used for modify function</span></span><br><span class="line"><span class="keyword">int</span> nn = <span class="number">0</span>,mm = <span class="number">0</span>,banX = <span class="number">-1</span>,banY = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>扩展及模拟节点</strong><br>在父节点为叶子节点时,  需要对父节点进行扩展,  这里需要对不可落子点进行判断, 使<br>得每个节点中的 x y 值都是可落子的.<br>模拟过程中即在当前状态下随机选取位置来落子,  并且判断是否分出了胜负, 在得到胜<br>负结果后向上进行更新</p></li><li><strong>计算 UCB 值</strong><br>每个节点 UCB 值的设计是蒙特卡洛算法中比较关键的一点,  分为两部分,  前部分为计算<br>该节点上的胜率,  胜率越高被选择的几率越大,  而后一部分则是为了平衡模拟方向,  使<br>得之前模拟次数越少的点越有机会被选中 <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nodes[sel].winRound/(nodes[sel].totRound+epsilon) +</span><br><span class="line">C*sqrt(log(nodes[fNode].totRound+1)/(nodes[sel].totRound+epsilon)))</span><br></pre></td></tr></table></figure></li></ol><ul><li>实现语言: c++</li><li>编译工具： g++</li><li>运行环境： Windows</li><li>编译方式：同目录下运行 makefile</li></ul><h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><strong> 与 62-100.dll 对战结果(胜场数/总场数)：</strong></p><table><thead><tr><th style="text-align:center">ai序号</th><th style="text-align:center">胜场/总场数</th></tr></thead><tbody><tr><td style="text-align:center">100.dll</td><td style="text-align:center">6/10</td></tr><tr><td style="text-align:center">98.dll</td><td style="text-align:center">7/10</td></tr><tr><td style="text-align:center">96.dll</td><td style="text-align:center">8/10</td></tr><tr><td style="text-align:center">94.dll</td><td style="text-align:center">8/10</td></tr><tr><td style="text-align:center">92.dll</td><td style="text-align:center">8/10</td></tr><tr><td style="text-align:center">90.dll</td><td style="text-align:center">8/10</td></tr><tr><td style="text-align:center">88.dll</td><td style="text-align:center">10/10</td></tr><tr><td style="text-align:center">86.dll</td><td style="text-align:center">9/10</td></tr><tr><td style="text-align:center">84.dll</td><td style="text-align:center">10/10</td></tr><tr><td style="text-align:center">82.dll</td><td style="text-align:center">10/10</td></tr></tbody></table><p><strong> 与 100.dll 对战 100 场(50rounds)结果(AI 为 A 方)：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Stat:</span><br><span class="line">ratio of A wins : 0.57</span><br><span class="line">ratio of B wins : 0.43</span><br><span class="line">ratio of Tie : 0</span><br><span class="line">ratio of (A wins + tie) : 0.57</span><br><span class="line">ratio of (B wins + tie) : 0.43</span><br></pre></td></tr></table></figure><h2 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h2><p>在测试过程中我打印了所选节点的胜率,  结果基本符合之前的收敛分析,  在 可以获胜的棋局中胜率逐渐增大,  而且当胜率增大到 65%时获胜几率十分大;同 样在胜率小于 40%时失败的几率也十分大.  在测试时如果将截止时间进一步增大 并且减少对超时的判断次数, 程序迭代的点个数可以接近 300W, 胜率也进一步 增大, 但这种情况下存在超时的风险.  综合来看蒙特卡洛算法可以较好的完成四子棋博弈的求解.</p>]]></content>
    
    <summary type="html">
    
      本实验对要求实现一个变种四子棋的 AI, 实验中对四子棋规则做了一定的扩展, 即随机 确定棋盘大小以及在棋盘上生成不可落子点.
    
    </summary>
    
      <category term="course" scheme="http://blog.dpatrickx.com/categories/course/"/>
    
    
      <category term="algorithm" scheme="http://blog.dpatrickx.com/tags/algorithm/"/>
    
      <category term="AI" scheme="http://blog.dpatrickx.com/tags/AI/"/>
    
      <category term="MCFS" scheme="http://blog.dpatrickx.com/tags/MCFS/"/>
    
  </entry>
  
  <entry>
    <title>FM划分算法</title>
    <link href="http://blog.dpatrickx.com/2016/01/14/fm/"/>
    <id>http://blog.dpatrickx.com/2016/01/14/fm/</id>
    <published>2016-01-14T07:19:00.000Z</published>
    <updated>2017-12-28T07:44:31.556Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h3><p>电路的划分(partition)是电路布图设计的第一步。<br>由于一个芯片包含众多晶体管，为了降低设计复杂度，通常需要把电路划分成若干模块，从而缩小问题规模。</p><p>划分时需要考虑的因素包括模块的大小、模块的数目和模块之间的连线等，如果各模块间连接(connection)数量过多，很可能会降低芯片的工作效率，因此电路划分的常见标准是最小化各划分块(partition)间连接的数量，同时各划分块也都要满足相应的设计要求，如块内逻辑数量设上限，块与外部连接(如I/O引脚)数量设上限等。<br>电路划分是一个NP问题，经常利用一些启发式算法来求解，FM算法就是其中的一种。</p><h3 id="2-建模过程-amp-方法"><a href="#2-建模过程-amp-方法" class="headerlink" title="2. 建模过程&amp;方法"></a>2. 建模过程&amp;方法</h3><p>FM算法中以加权有向图的形式对电路进行建模，一个划分即对一张图求得一个割集(二分情况)。<br>在有向图基础上，算法规定了一些相应概念，以下就各引入概念作一定说明。</p><ul><li><strong>Graph(V,E)</strong>： 一个电路使用一个有向图来表示，其中点集V中每一点都对应一个pin,并且每个点都有相应权值，边集E中每条边都对应一个点与点的连接(connection)。</li><li><p><strong>Net</strong>: 多个相连的边(连接)就组成一个net，其中在同一个划分内的net称为<strong>uncut net</strong>，反之则为<strong>cut net</strong>，如下图，共有5个net，其中2、3、4均为cut net，1和5则为uncut net；</p><p><img src="http://i.imgur.com/JA1NkSD.png" alt="1"></p></li><li><strong>FS()</strong>：一个pin的FS值定义为与其相连且不与同一划分中其他pin相连的net的数量，如上图中FS(a)=2；</li><li><strong>TE()</strong>：一个pin的TE值定义为与其相连的uncut net的数量，如上图，TE(a)=1；</li><li><strong>gain()</strong>：一个pin的gain值定义为gain(a)=FS(a)-TE(a)，如上图，gain(a)=1；</li><li><strong>ratio factor</strong>：为防止在划分过程中所有pin均被分入一边，加入此常数保持平衡；</li><li><strong>Balanced Criterion</strong>：在得到两个划分A和B后，使用该方法来判断两个划分是否平衡，即只有满足如下条件的两个划分才算是平衡。<br><img src="http://i.imgur.com/YQZyVzj.jpg" alt="2"></li></ul><p>从以上定义不难发现一个pin的gain值大小就可以看做这个pin是否应该“迁移”的标准，这也为FM求解算法做好了基础准备。</p><h3 id="3-求解算法"><a href="#3-求解算法" class="headerlink" title="3. 求解算法"></a>3. 求解算法</h3><h4 id="FM算法I-O简要描述："><a href="#FM算法I-O简要描述：" class="headerlink" title="FM算法I/O简要描述："></a>FM算法I/O简要描述：</h4><ul><li>输入：有向图、初始划分</li><li>输出：求解出的划分结果</li></ul><h4 id="FM算法大致流程"><a href="#FM算法大致流程" class="headerlink" title="FM算法大致流程"></a>FM算法大致流程</h4><p>在初始划分基础上，每次移动一个pin(算法中对应为<strong>cell</strong>)，最终求得一个使划分间连接最小化的结果。<br>一次pin的移动称为一个<strong>pass</strong>，FM算法即进行多次pass后得到最终解(不一定最优)。</p><p><img src="http://i.imgur.com/g1wMCv6.jpg" alt="3"></p><h4 id="FM算法具体流程-——-整体循环"><a href="#FM算法具体流程-——-整体循环" class="headerlink" title="FM算法具体流程 —— 整体循环"></a>FM算法具体流程 —— 整体循环</h4><p>FM算法整体流程如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>  Compute balance criterion</span><br><span class="line"><span class="number">2.</span>  While(there is better partition)</span><br><span class="line"><span class="number">3.</span>          Find a pass</span><br><span class="line"><span class="number">4.</span>          execute the pass</span><br><span class="line"><span class="number">5.</span>  Find finally solution</span><br></pre></td></tr></table></figure></p><p>即反复根据当前有向图求得一个pass，检查是否存在更优解，如果不存在，则当前划分就是最终划分，结束算法。</p><h4 id="FM算法具体流程-——-求解pass"><a href="#FM算法具体流程-——-求解pass" class="headerlink" title="FM算法具体流程 —— 求解pass"></a>FM算法具体流程 —— 求解pass</h4><p>FM算法中一个pass即从一个划分中移动一个cell到另一划分，求解流程如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Set each cell as FREE</span><br><span class="line"><span class="number">2.</span> Compute gain of each cell</span><br><span class="line"><span class="number">3.</span> While (there are FREE cells)</span><br><span class="line"><span class="number">4.</span>         find the cell with maximum gain</span><br><span class="line"><span class="number">5.</span>         move the cell</span><br><span class="line"><span class="number">6.</span>         keep track of cells moved</span><br><span class="line"><span class="number">7.</span>         update gains of relevant pins</span><br><span class="line"><span class="number">8.</span>         mark the cell moved as FIXED</span><br><span class="line"><span class="number">9.</span> Get maximum G from moved-cells sequence</span><br></pre></td></tr></table></figure></p><p>每次求解都需要进行O(|pins|)的操作，每次都选取未移动过的cell中gain值最大者进行移动(移动到另一个划分)，这样一个循环后就得到一个移动序列，根据此序列即可求出一个pass。</p><h4 id="FM算法具体流程-——-求gain值最大cell"><a href="#FM算法具体流程-——-求gain值最大cell" class="headerlink" title="FM算法具体流程 —— 求gain值最大cell"></a>FM算法具体流程 —— 求gain值最大cell</h4><p>在求gain值最大cell时，除过比较gain值，还需要满足一定条件，具体流程如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> After moving, area(A) must satisfy the Balanced Criterion</span><br><span class="line"><span class="number">2.</span> Maximum gain cell</span><br><span class="line"><span class="number">3.</span> Multiple cells meet, keep partition sizes most close to the mid of Criterion</span><br></pre></td></tr></table></figure></p><p>在多个cell满足时，选取使划分更接近中间(即两个划分更接近)的cell，这也从直观上也很容易理解。两个面积相近的划分也更有利与接下来电路布图的设计。</p><h4 id="FM算法具体流程-——-更新cell的gain值"><a href="#FM算法具体流程-——-更新cell的gain值" class="headerlink" title="FM算法具体流程 —— 更新cell的gain值"></a>FM算法具体流程 —— 更新cell的gain值</h4><p>在移动了一个cell后，两个相应划分的情况都发生了改变，因此两个划分中各cell的gain值也需要重新进行计算，这里可以选择用定义方法重新求解，但这样肯定会导致程序效率较低，显然需要找到更好的方法来更新各cell的gain值。<br>这里需要引入一个新的概念，<strong>关键网(critical nets)</strong>，即<strong>在移动cell前后cut状态改变的网</strong>，关键网的概念对于更新gain值的计算很有帮助，因为<strong>只有与被移动cell以关键网相连的cell才会发生gain值的改变</strong>。</p><ul><li><p>关键网的判定：移动前后如果在任一划分中只有一个或没有cell处于net中，即为一个关键网，下图很直观地体现了四种情况。</p><p><img src="http://i.imgur.com/UNlZSaH.jpg" alt="4"></p></li><li><p>利用关键网进行gain值更新<br>分四种情况，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">T(net): number of cells of to-side before moving</span><br><span class="line">F'(net): number of cells of from-side after moving</span><br><span class="line"><span class="number">1.</span> T(net)=<span class="number">0</span>, gain of all <span class="built_in">free</span> cells of from-side + <span class="number">1</span></span><br><span class="line"><span class="number">2.</span> T(net)=<span class="number">1</span>, gain of all <span class="built_in">free</span> cells of to-side – <span class="number">1</span></span><br><span class="line"><span class="number">3.</span> F'(net)=<span class="number">0</span>, gain of all <span class="built_in">free</span> cells of to-side – <span class="number">1</span></span><br><span class="line"><span class="number">4.</span> F'(net)=<span class="number">1</span>, gain of all <span class="built_in">free</span> cells of from-side + <span class="number">1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="FM算法具体流程-——-根据移动序列求解pass"><a href="#FM算法具体流程-——-根据移动序列求解pass" class="headerlink" title="FM算法具体流程 —— 根据移动序列求解pass"></a>FM算法具体流程 —— 根据移动序列求解pass</h4><p>在这个序列中，每一项都记录了此次移动后的划分情况以及gain值的变化量；<br>对序列前m项的变化量求和，取得最大值时的m对应的划分情况即为一个pass；<br>如果多个m满足，则还是按照<strong>最接近一半</strong>的原则确定是哪一个m。</p><h3 id="4-实验"><a href="#4-实验" class="headerlink" title="4. 实验"></a>4. 实验</h3><ul><li>编程语言： c++</li><li>编译环境： g++</li><li>运行环境： windows/linux/mac</li></ul><h4 id="测试样例1"><a href="#测试样例1" class="headerlink" title="测试样例1"></a>测试样例1</h4><p>采用一组已有教程中给出的样例来测试，电路状况如下，初始划分为a/b：<br><img src="http://i.imgur.com/JA1NkSD.png" alt="5"><br>运行所得结果如下<br><img src="http://i.imgur.com/XefkATl.png" alt="res1"><br>两次pass后求得最终结果，也是最优解。</p><h4 id="测试样例1-——-不同初始划分"><a href="#测试样例1-——-不同初始划分" class="headerlink" title="测试样例1 —— 不同初始划分"></a>测试样例1 —— 不同初始划分</h4><p>采用同样样例，但将初始划分改为a，b，c，运行结果如下<br><img src="http://i.imgur.com/eSpN3Zx.png" alt="res2"><br>可以看到只用了一次pass，得到了同样的结果。</p><h4 id="测试样例2"><a href="#测试样例2" class="headerlink" title="测试样例2"></a>测试样例2</h4><p>我们手动构建了一个测试样例，cell个数为17，最优划分为0，1，2，3，4，5，6，7，在不同初始划分下运行结果如下：</p><table><thead><tr><th style="text-align:center">ratio factor</th><th style="text-align:center">初始划分</th><th style="text-align:center">运行结果</th></tr></thead><tbody><tr><td style="text-align:center">0.5</td><td style="text-align:center">0~8</td><td style="text-align:center">0~7</td></tr><tr><td style="text-align:center">0.5</td><td style="text-align:center">0~6</td><td style="text-align:center">0~7</td></tr><tr><td style="text-align:center">0.5</td><td style="text-align:center">0~5</td><td style="text-align:center">0~7</td></tr><tr><td style="text-align:center">0.4</td><td style="text-align:center">0~4</td><td style="text-align:center">0~6</td></tr><tr><td style="text-align:center">0.4</td><td style="text-align:center">0~3</td><td style="text-align:center">0~6</td></tr></tbody></table><ul><li>可以看到运行结果和ratio factor以及初始划分的选定都有一定关系</li><li>不一定每次都取到最优解</li></ul><h4 id="测试样例3"><a href="#测试样例3" class="headerlink" title="测试样例3"></a>测试样例3</h4><p>因为没有找到带有正确答案的大规模测试样例，所以我们自己构建了几组较大规模的数据来测试运行时间(<strong>2 passes for each instance</strong>)。</p><table><thead><tr><th style="text-align:center">数据规模</th><th style="text-align:center">运行时间/S</th></tr></thead><tbody><tr><td style="text-align:center">100</td><td style="text-align:center">0.085</td></tr><tr><td style="text-align:center">1000</td><td style="text-align:center">1.354</td></tr><tr><td style="text-align:center">10000</td><td style="text-align:center">48.18</td></tr><tr><td style="text-align:center">20000</td><td style="text-align:center">190.3</td></tr></tbody></table><ul><li>因为包含输出，会影响一定速度</li></ul><h4 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h4><ul><li>为方便程序数据从同目录下init.txt中读入，需要预先写入电路数据，顺序为<ul><li>factor ratio</li><li>number of cell</li><li>area of each cell</li><li>number of net</li><li>cell connected by each net</li><li>initial partition</li></ul></li><li>factor ratio及initial partition的选取会影响到程序运行结果，可采用公式<strong>factor ratio = |init cells|/|all cells|</strong></li></ul><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><ul><li>FM算法很容易陷入局部最优中，从算法过程不难发现，FM算法要求每一步都做到“更优”，这样几乎不可能跳出局部最优，因此在实际应用中FM算法经常与一些随机性较好的算法混合使用；</li><li>在本算法中，只会得到二分的结果，因为在未加更多限制条件的情况下，要最小化connection数量，二分肯定是最好结果，如果加上更多的限制，FM算法可以进行相应改动来获取多部分的划分。</li></ul><p><strong>参考资料： 《Netlist and System Partitioning》</strong></p>]]></content>
    
    <summary type="html">
    
      电路的划分(partition)是电路布图设计的第一步。由于一个芯片包含众多晶体管，为了降低设计复杂度，通常需要把电路划分成若干模块，从而缩小问题规模
    
    </summary>
    
      <category term="course" scheme="http://blog.dpatrickx.com/categories/course/"/>
    
    
      <category term="VLSI" scheme="http://blog.dpatrickx.com/tags/VLSI/"/>
    
      <category term="algorithm" scheme="http://blog.dpatrickx.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>简易DBMS的c++实现报告</title>
    <link href="http://blog.dpatrickx.com/2015/12/20/database/"/>
    <id>http://blog.dpatrickx.com/2015/12/20/database/</id>
    <published>2015-12-20T13:20:00.000Z</published>
    <updated>2017-12-28T07:27:00.394Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><p>实验在IO方面主要调用的是提供好的BufPageManager和FileManager, 并对其进行了一系列的封装操作. 其中, BufPageManager中的文件即项目中所提的表, 项目中数据库的实现即所有表存放的一个文件夹. 由于BufPageManager每次读写一页大小为8kb, 因此将8kb作为一个页的大小.</p><p>每创建一个表时, 系统将初始化32个页作为该表的初始容量. 每个表的第零页存储该表共有的页数n（4B）, 以及大小为n的bitmap存储相应的页是否有空槽. 每个页大小为8KB. 由于每个表在创建的时候, 每条项目的最大长度是固定的, 所以以该最大长度作为每一个项目的长度, 并根据该长度确定每一页中最多存入多少条. 这里需要说明每一页存储的格式. 在每一页的尾端系统会维护一个长度为最多存入条数的bitmap, 用来记录每个槽位是否有条目占用. 同时, 在每个存入的条目末尾, 项目会维护一个长度为每个条目中属性个数的bitmap, 用来记录该条目对应的属性是否为NULL. 具体的页结构见如下示意图：<br><img src="http://i.imgur.com/iLVqERU.png" alt="1"></p><h3 id="系统功能"><a href="#系统功能" class="headerlink" title="系统功能"></a>系统功能</h3><p>支持MySQL的一些系列基本操作：Create语句（创建数据库DATABASE, 创建表TABLE）, Drop语句, Select语句, Delete语句, Insert语句, Update语句, DESC语句. 同时能够支持其他功能有：多表连接, 聚集查询, 聚集查询, 分组聚集查询, 模糊匹配, 外键约束, 运算符和运算表达式等.</p><h3 id="主要模块设计原理"><a href="#主要模块设计原理" class="headerlink" title="主要模块设计原理"></a>主要模块设计原理</h3><h4 id="1-记录管理模块"><a href="#1-记录管理模块" class="headerlink" title="1. 记录管理模块"></a>1. 记录管理模块</h4><p>该模块主要负责底层有关table的相关操作, 实现一些类和方法对存储记录的文件进行管理. 实现这个模块的主要内容在系统所定义的Table类中, 这个类中一些需要维护的属性如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> _fileID;</span><br><span class="line">    <span class="keyword">int</span> length;     <span class="comment">// length of item / byte</span></span><br><span class="line">    <span class="keyword">int</span> slotNum;    <span class="comment">// number of data slot</span></span><br><span class="line">    <span class="keyword">int</span> bitSize;    <span class="comment">// number of bitmap bits in the end of page</span></span><br><span class="line">    <span class="keyword">int</span> typeNum;</span><br><span class="line">    uint pageNum;   <span class="comment">// first 4 bytes of first page of the file</span></span><br><span class="line">    <span class="keyword">int</span> nullPos;     <span class="comment">// offset of null bitmap in each item</span></span><br><span class="line">    <span class="keyword">int</span> freeNumPos;  <span class="comment">// freeMapPos - 4</span></span><br><span class="line">    <span class="keyword">int</span> freeMapPos;  <span class="comment">// offset of free bitmap in each page</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tbName;</span><br><span class="line">    <span class="built_in">string</span> path;    <span class="comment">// path/tbName.txt</span></span><br><span class="line">    <span class="built_in">string</span> priKey;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; offset;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; sequence;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &gt; check;</span><br><span class="line">    Attr example;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>说明：length表示每个条目的最大长度, slotNum表示每个页可供使用的槽的数目, bitSize指的是每页最后的Bitmap大小, typeNum指的是每个条目中的属性的数量, pageNum指的是一个Table中所拥有的页数, nullPos指的是每个条目最后bitmap相对于该条目起始位置的偏移量, offset保存了每个条目中的每个属性相对于该条目起始位置的偏移量, sequence保存了各个属性的名称, check保存了响应属性名称的域完整性约束, example是一个样例条目：保存了每个条目的最大长度, 条目中每个属性的类型以及长度</p></blockquote><p>在每个表中系统还维护了一个hashMap, 用来保存主键的取值, 如果待插入条目中的主键值已经存在于hashMap中, 则报错.<br>    <strong>- 插入操作：</strong><br>    主要的实现的功能为维护域完整性, 主键重复报错, 以及插入条目中存在null时的判断. 在插入一个新条目之前, 程序先查看每个表的第零页, 找到存在空槽的页, 然后查看该页尾端的bitmap, 确定一个空槽的位置, 也就是插入的位置. 然后进行check以及主键的检查工作. 接着程序会根据example对每个条目的描述来确定插入的信息, 并根据offset中记录的每个属性的偏移量来进行插入操作.<br>    <strong>- 删除操作：</strong><br>    当一个条目待删除时, 系统不会将存储有该条目内容的槽位清空, 而是会把对应页尾端bitmap的值置为“空闲”, 这样在查询和插入操作进行的时候, 访问页尾端的bitmap即可知道哪些条目存在, 哪些是空槽, 就不必每条都进行访问, 从而提高了效率.<br>    <strong>- 更新操作：</strong><br>    当更新一个条目的时候, 系统首先会调用一个名为conform的函数来对更新的条件与每个条目进行匹配, 如果一个条目符合条件, 则在相对位置上重写条目即可. 由于example样例条目的存在, 系统会根据条目中属性的类型以及长度先提取出待更新的条目, 然后对需要更新的属性进行更新, 在重新写入相应的槽位即可.<br>    <strong>- 查询操作</strong><br>    与更新操作类似, 系统会调用conform函数来匹配条件与每个条目, 并输出相应查找的属性. </p><h4 id="2-系统管理模块"><a href="#2-系统管理模块" class="headerlink" title="2. 系统管理模块"></a>2. 系统管理模块</h4><p>首先介绍sql语句的解析过程, 如下图所示<br><img src="http://i.imgur.com/ffQYyyX.jpg" alt="main"><br>其中</p><ul><li>YACC是利用yacc工具进行的语法解析类；</li><li>DBManager类记录并管理所有的database, 利用单例模式构建；</li><li>DataBase类是一个database的实例, 记录有database的表单等信息；</li><li>Table类管理一个表单, 可以对一个table进行item的操作(添加/删除/更改等).</li></ul><p>在数据库存储中, 每个database对应一个文件夹, 而每个table对应一个文本文件. 因此在系统管理模块需要对本地数据进行相应更改, 结合语句简要说明如下：</p><ul><li>创建数据库：DBManager类中的database队列增加相应记录, 并在本地创建文件夹；</li><li>删除数据库：DBManager类中移除相应database, 并将本地文件夹移除；</li><li>切换数据库：在DBManager中记录当前数据库, 更改该属性即可；</li><li>创建表： 在相应DataBase类中增加相应table记录, 在该文件夹下增加相应文本文件；</li><li>删除表： 在相应DataBase类中移除相应table记录, 在该文件夹下删除相应文本文件.</li></ul><h4 id="3-查询解析模块"><a href="#3-查询解析模块" class="headerlink" title="3. 查询解析模块"></a>3. 查询解析模块</h4><p>语句解析部分和<strong><em>系统管理模块</em></strong>部分相同.<br>在YACC解析到相应语句后, 会借助DBManager来调用相应database中的table类来进行相应操作.<br><strong>以下部分以<code>insert</code>语句为例说明整个过程：</strong><br><strong>1. yacc语法解析</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insertsql:</span><br><span class="line">    INSERT INTO IDENTIFIER &apos;(&apos; tableitems &apos;)&apos; VALUES valuesql &#123;</span><br><span class="line">        $$.init($3, $5, $8);</span><br><span class="line">        $$.display();</span><br><span class="line">        $$.work();</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure></p><p>利用yacc解析出insertsql后直接调用相应类的work函数.<br><strong>2. DBManager获取DataBase</strong><br>work函数直接调用DBManager类的相应函数<code>tbWork</code>, 而在该函数中会先获取相应DataBase类, 然后调用该DataBase类的函数<code>insertTB</code>;<br><strong>3. DataBase获取Table</strong><br>在DataBase中会先获取对应table类, 然后调用table的函数<code>select</code>；<br><strong>4. Table调用insert函数</strong><br>相应table执行insert函数, 函数原理见 <strong><em>记录管理模块</em></strong></p><h4 id="4-附加模块："><a href="#4-附加模块：" class="headerlink" title="4. 附加模块："></a>4. 附加模块：</h4><ul><li><p>域完整性约束, 建表时的check关键字<br>由于系统在表中有关于域完整性约束的map, 所以在新加入一个条目的时候只需查找对应map条目中是否包含添加的项, 如果不包含则报错；</p></li><li><p>外键约束<br>外键约束由于系统对于每个表都维护了一个hashMap, 所以只需查找相应表中的hashMap即可判断是否违反外键约束；</p></li><li><p>模糊匹配<br>模糊匹配系统使用了c++11, 因为c++11中能够采用正则表达式, 系统对于每个输入的模糊匹配串都做了如下处理：将%替换为.*, 将_替换为., 这样就可以用待匹配串与每个条目相应属性的值做正则匹配. </p></li><li><p>三个表以上的连接<br>由于系统未能有效实现索引功能, 所以多表连接问题系统采用的是最原始的暴力搜索方法, 不过在搜索过程中系统还是做了一些优化, 使得每搜索一个正确条目所用的时间并不显得十分长（但是计算复杂度可知相应的时间消耗依旧是n^2级别的）</p></li><li><p>聚集查询<br>聚集查询系统默认待查询的属性的类型为int, 所以只需将表遍搜, 然后获取相应查询操作的结果即可. </p></li><li><p>分组聚集查询<br>分组聚集查询是在聚集查询的基础上用一个临时的map将不同类别的值分别存储, 从而达到分组的目的. </p></li></ul><h4 id="5-数据库信息存储"><a href="#5-数据库信息存储" class="headerlink" title="5. 数据库信息存储"></a>5. 数据库信息存储</h4><p>以上所描述各用于维持数据库的类在程序结束时会依次写入本地文件中, 在下次程序运行时会先读入该部分数据, 完成各类的恢复工作. </p><h3 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h3><ul><li>主程序及makefile文件均在在/yacc/目录下, 利用该makefile即可进行编译, 生成主程序main；</li><li>需要预先安装库：flex、bison、g++；</li><li>主程序运行方式：直接运行主程序, 之后需要输入一个参数(0或1)：<ul><li>1表示不读入本地文件, 重新构建一个数据库</li><li>0表示读入本地文件, 即恢复到上次程序结束时的状态</li><li>在首次运行时需要输入1, 之后使用0参数即可</li></ul></li></ul><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><p>实验结果表明, 此数据库文件系统可以很好地完成系统管理模块以及查询解析模块的相应工作, 并且能够很好地执行附加模块中域完整性约束、模糊匹配、聚集查询、分组聚集查询, 由于系统没有实现索引模块, 所以在外键约束和三个表以上的连接的功能上实现的效率不是很高, 因为采用的是暴力搜索的方法. </p><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>1. 系统管理模块</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> tempDB;</span><br><span class="line"><span class="keyword">USE</span> tempDB;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> publisher(</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">state <span class="built_in">varchar</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>;</span><br><span class="line">DESC publisher;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> publisher;</span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> tempDB;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">SQL: <span class="keyword">show</span> <span class="keyword">table</span></span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"><span class="keyword">tables</span> <span class="keyword">in</span> tempDB</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line">publisher</span><br><span class="line">+<span class="comment">--------------------+</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SQL</span>:  <span class="keyword">desc</span> <span class="keyword">table</span> publisher</span><br><span class="line">+<span class="comment">-------------+-------------+------+-----+</span></span><br><span class="line">| <span class="keyword">Field</span>       | <span class="keyword">Type</span>        | <span class="literal">Null</span> | <span class="keyword">Key</span> |</span><br><span class="line">+<span class="comment">-------------+-------------+------+-----+</span></span><br><span class="line">| <span class="keyword">id</span> | <span class="built_in">INT</span>(<span class="number">10</span>) | <span class="keyword">NO</span>  | PRI |</span><br><span class="line">| <span class="keyword">name</span> | <span class="built_in">VARCHAR</span>(<span class="number">25</span>) | <span class="keyword">NO</span>  |     |</span><br><span class="line">| state | <span class="built_in">VARCHAR</span>(<span class="number">25</span>) | <span class="keyword">NO</span>  |     |</span><br><span class="line">+<span class="comment">-------------+-------------+------+-----+</span></span><br></pre></td></tr></table></figure></p><p><strong>2. 查询解析模块</strong></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> publisher <span class="keyword">VALUES</span> (<span class="number">105001</span>, <span class="string">'American Technical Publisher'</span>, <span class="string">'GA'</span>);</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> publisher <span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">105001</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">id: 105001</span><br><span class="line">name: American Technical Publisher</span><br><span class="line">state: GA</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer <span class="keyword">VALUES</span> (<span class="number">300002</span>, <span class="string">'CHAD CABELLO'</span>, <span class="string">'F'</span>);</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Primary Key Conflict!</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders <span class="keyword">VALUES</span> (<span class="number">304403</span>, <span class="number">200001</span>, <span class="string">'eight'</span>);</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INPUT ERROR</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> quantity &lt; <span class="number">2</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> quantity &lt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为空</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> book <span class="keyword">SET</span> title=<span class="string">'Nine Times Nine'</span> <span class="keyword">WHERE</span> <span class="keyword">authors</span>=<span class="string">'David Ray'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> <span class="keyword">authors</span>=<span class="string">'David Ray'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Nine Times Nine</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> book <span class="keyword">SET</span> copies=<span class="string">'eight'</span> <span class="keyword">WHERE</span> title=<span class="string">'A Walk Through the Fire'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Update Input Error</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> publisher <span class="keyword">WHERE</span> state=<span class="string">'CA'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果(选取部分)</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">id: 104992</span><br><span class="line">name: China Books &amp;amp; Periodicals</span><br><span class="line">state: CA</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">id: 104993</span><br><span class="line">name: Dow Jones &amp;amp; Company, Inc.</span><br><span class="line">state: CA</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">id: 104994</span><br><span class="line">name: Fox Chapel Publishing Company</span><br><span class="line">state: CA</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">id: 104996</span><br><span class="line">name: W.h. Smith And Son Publishers</span><br><span class="line">state: CA</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">id: 104997</span><br><span class="line">name: Transworld Publishers Limited</span><br><span class="line">state: CA</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> title <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> <span class="keyword">authors</span> <span class="keyword">is</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: Anyone Can Have a Happy</span><br></pre></td></tr></table></figure></p><p><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> book.title, publisher.name, publisher.state <span class="keyword">FROM</span> book, publisher <span class="keyword">WHERE</span> book.publisher_id=publisher.id <span class="keyword">AND</span> publisher.state=<span class="string">'CA'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果(选取部分)</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">*** publisher ***</span><br><span class="line">state: CA</span><br><span class="line">*** publisher ***</span><br><span class="line">name: Anglican Book Centre</span><br><span class="line">*** book ***</span><br><span class="line">title: Exortacao Aos Crocodilos</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** publisher ***</span><br><span class="line">state: CA</span><br><span class="line">*** publisher ***</span><br><span class="line">name: Lyle Stuart Hardcover</span><br><span class="line">*** book ***</span><br><span class="line">title: The Rancher Takes a Wife</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** publisher ***</span><br><span class="line">state: CA</span><br><span class="line">*** publisher ***</span><br><span class="line">name: Linstok Press, Incorporated</span><br><span class="line">*** book ***</span><br><span class="line">title: Flambards (Puffin Books)</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** publisher ***</span><br><span class="line">state: CA</span><br><span class="line">*** publisher ***</span><br><span class="line">name: Bantam Doubleday Dell Pub</span><br><span class="line">*** book ***</span><br><span class="line">title: A Tall Man in a Low Land</span><br></pre></td></tr></table></figure></p><p><strong>3. 域完整性约束</strong><br><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> customer <span class="keyword">VALUES</span> (<span class="number">307001</span>, <span class="string">'CHAD CABELLO'</span>, <span class="string">'Male'</span>);</span><br><span class="line"><span class="keyword">UPDATE</span> publisher <span class="keyword">SET</span> state=<span class="string">'HI'</span> <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">'New Video Group Inc'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Check</span> <span class="keyword">error</span></span><br><span class="line"><span class="keyword">Check</span> <span class="keyword">error</span></span><br></pre></td></tr></table></figure></p><p><strong>4. 外键约束</strong><br><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> book <span class="keyword">SET</span> publisher_id=<span class="string">'106001'</span> <span class="keyword">WHERE</span> title=<span class="string">'A Voice Through a Cloud'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Against publisher Key Restriction</span><br></pre></td></tr></table></figure></p><p><strong>5. 模糊匹配</strong><br><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, gender <span class="keyword">FROM</span> customer <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'_USTY%'</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">*** customer ***</span><br><span class="line">gender: F</span><br><span class="line">*** customer ***</span><br><span class="line">name: RUSTY PITTARD</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: F</span><br><span class="line">*** customer ***</span><br><span class="line">name: RUSTY FELT</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: M</span><br><span class="line">*** customer ***</span><br><span class="line">name: RUSTY SANNER</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: M</span><br><span class="line">*** customer ***</span><br><span class="line">name: DUSTY DEMELO</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: F</span><br><span class="line">*** customer ***</span><br><span class="line">name: RUSTY DACUS</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: F</span><br><span class="line">*** customer ***</span><br><span class="line">name: DUSTY LIRETTE</span><br><span class="line"><span class="comment">-------------------------</span></span><br><span class="line">*** customer ***</span><br><span class="line">gender: M</span><br><span class="line">*** customer ***</span><br><span class="line">name: DUSTY KUEHN</span><br></pre></td></tr></table></figure></p><p><strong>6. 三个表以上的连接</strong><br><strong>SQL</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> customer.name,book.title,orders.quantity <span class="keyword">FROM</span> customer,book,orders</span><br><span class="line"><span class="keyword">WHERE</span> orders.customer_id=customer.id <span class="keyword">AND</span> orders.book_id=book.id <span class="keyword">AND</span> orders.quantity &gt; <span class="number">8</span>;</span><br></pre></td></tr></table></figure></p><p><strong>因未加索引模块, 此部分运行时间过长, 不展示结果</strong></p><p><strong>7. 聚集查询</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(quantity) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id=<span class="number">304403</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(quantity) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id=<span class="number">304403</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(quantity) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id=<span class="number">304403</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MIN</span>(quantity) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id=<span class="number">304403</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> customer_id=<span class="number">304403</span>;</span><br></pre></td></tr></table></figure></p><p><strong>结果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">SQL:  <span class="keyword">select</span> <span class="keyword">sum</span>(quantity), <span class="keyword">from</span> orders</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line"><span class="keyword">SUM</span>(quantity): <span class="number">23</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="keyword">SQL</span>:  <span class="keyword">select</span> <span class="keyword">avg</span>(quantity), <span class="keyword">from</span> orders</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line"><span class="keyword">AVG</span>(quantity): <span class="number">4</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="keyword">SQL</span>:  <span class="keyword">select</span> <span class="keyword">max</span>(quantity), <span class="keyword">from</span> orders</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line"><span class="keyword">MAX</span>(quantity): <span class="number">9</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="keyword">SQL</span>:  <span class="keyword">select</span> <span class="keyword">min</span>(quantity), <span class="keyword">from</span> orders</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line"><span class="keyword">MIN</span>(quantity): <span class="number">2</span></span><br><span class="line"><span class="comment">-------------------</span></span><br><span class="line"><span class="keyword">SQL</span>:  <span class="keyword">select</span> <span class="keyword">count</span>(*), <span class="keyword">from</span> orders</span><br><span class="line">+<span class="comment">------------------------------+</span></span><br><span class="line"><span class="keyword">COUNT</span>(*): <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p><strong>8. 分组聚焦查询</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(quantity) <span class="keyword">FROM</span> orders <span class="keyword">GROUP</span> <span class="keyword">BY</span> customer_id;</span><br></pre></td></tr></table></figure></p><p><strong>结果(展示部分)</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">306981: SUM(quantity): 11</span><br><span class="line">306982: SUM(quantity): 7</span><br><span class="line">306983: SUM(quantity): 15</span><br><span class="line">306984: SUM(quantity): 17</span><br><span class="line">306985: SUM(quantity): 27</span><br><span class="line">306986: SUM(quantity): 31</span><br><span class="line">306987: SUM(quantity): 3</span><br><span class="line">306988: SUM(quantity): 20</span><br><span class="line">306989: SUM(quantity): 30</span><br><span class="line">306990: SUM(quantity): 17</span><br><span class="line">306991: SUM(quantity): 39</span><br><span class="line">306992: SUM(quantity): 24</span><br><span class="line">306993: SUM(quantity): 8</span><br><span class="line">306994: SUM(quantity): 39</span><br><span class="line">306995: SUM(quantity): 6</span><br><span class="line">306996: SUM(quantity): 32</span><br><span class="line">306997: SUM(quantity): 13</span><br><span class="line">306998: SUM(quantity): 28</span><br><span class="line">306999: SUM(quantity): 11</span><br><span class="line">307000: SUM(quantity): 39</span><br></pre></td></tr></table></figure></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>[1]. 数据库系统设计与原理 第二版 冯建华 周立柱 郝晓龙 编著</p><p>[2]. 数据库系统概念 Silberschatz Korth Sudarshan 著 杨冬青等 译</p><h3 id="项目github链接："><a href="#项目github链接：" class="headerlink" title="项目github链接："></a>项目github链接：</h3><p><a href="https://github.com/dpatrickx/dbclass" target="_blank" rel="noopener">dbclass project</a></p>]]></content>
    
    <summary type="html">
    
      实验在IO方面主要调用的是提供好的BufPageManager和FileManager, 并对其进行了一系列的封装操作.
    
    </summary>
    
      <category term="course" scheme="http://blog.dpatrickx.com/categories/course/"/>
    
    
      <category term="DBMS" scheme="http://blog.dpatrickx.com/tags/DBMS/"/>
    
  </entry>
  
</feed>
